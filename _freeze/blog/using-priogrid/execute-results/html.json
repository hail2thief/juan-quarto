{
  "hash": "cb7bb24218980cb634bb015413d5797d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Working with PRIO-GRID data\"\ndate: today\nsubtitle: Walkthrough of the PRIO-GRID data in R.\npage-layout: full\ntitle-block-banner: false\nformat:\n  html:\n    anchor-sections: false\n---\n\n\n\n\n\n\n\n\n\n\n## PRIO-GRID data\n\n\nPRIO-GRID breaks up the Earth into a grid of little squares, or cells, each of which is 0.5 x 0.5 decimal degrees (roughly 50 x 50 km at the equator; you can read more about the data [here](https://journals.sagepub.com/doi/full/10.1177/0022343311431287)). Researchers then conformed a variety of available spatial data to this grid system, giving users access to things like the population of each 50 x 50 km square everywhere on the globe.\n\n\nThe data come in three forms: \n\n1. `Shapefiles`: information for plotting and doing spatial analysis on the grid system\n2. `Static variables`: data at the cell-level on stuff that doesn't change (e.g., how mountainous that cell is)\n3. `Yearly variables`: data at the cell-level that changes over time (e.g., rain, population, etc.)\n\n\n\n## Spatial data in R\n\nThere are two main packages for dealing with spatial data in R:\n\n- `spdep`: older, richer set of functions, not-tidy\n- `sf`: newer, fewer functions, tidy\n\n\nI would rather only use `sf`, but there are some nice functions in `spdep` we'll need to use in this example that I'm not sure I can replicate in `sf`. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# libraries\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(spdep)\n\n# theme\ntheme_set(theme_minimal())\n```\n:::\n\n\n\n\nThe starting point of the data is [the cells themselves](https://grid.prio.org/#/extensions), stored as a shapefile. We can interact with shapefiles with the great `sf` library:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid = read_sf(\"/Users/juan/Downloads/priogrid_cellshp/priogrid_cell.shp\")\nhead(grid)\n## Simple feature collection with 6 features and 5 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 163.5 ymin: 89.5 xmax: 166.5 ymax: 90\n## Geodetic CRS:  WGS 84\n## # A tibble: 6 × 6\n##      gid xcoord ycoord   col   row                                               geometry\n##    <dbl>  <dbl>  <dbl> <dbl> <dbl>                                          <POLYGON [°]>\n## 1 259168   164.   89.8   688   360 ((163.5 89.5, 163.5 90, 164 90, 164 89.5, 163.5 89.5))\n## 2 259169   164.   89.8   689   360   ((164 89.5, 164 90, 164.5 90, 164.5 89.5, 164 89.5))\n## 3 259170   165.   89.8   690   360 ((164.5 89.5, 164.5 90, 165 90, 165 89.5, 164.5 89.5))\n## 4 259171   165.   89.8   691   360   ((165 89.5, 165 90, 165.5 90, 165.5 89.5, 165 89.5))\n## 5 259172   166.   89.8   692   360 ((165.5 89.5, 165.5 90, 166 90, 166 89.5, 165.5 89.5))\n## 6 259173   166.   89.8   693   360   ((166 89.5, 166 90, 166.5 90, 166.5 89.5, 166 89.5))\n```\n:::\n\n\nEach row in this tibble is a cell; there are almost 260,000 of them. The key columns are `gid` (a unique identifier for each grid cell) and `geometry` which `{sf}` can work with for map-making and other spatial data stuff. \n\n\n## Merging in the yearly data\n\nThe grid of cells itself doesn't have much use without other information. We'll need to merge in other variables, such as what country each cell is in. This is stored as [yearly data by PRIO](https://grid.prio.org/#/download). Note: for the yearly variables we can choose a start and end date, but each variable varies in what years of data it has available. Below, I choose a few variables from the year 2010:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyearly_prio = read_csv(\"/Users/juan/Downloads/PRIO-GRID Yearly Variables for 2010-2010 - 2024-08-26.csv\")\nyearly_prio\n## # A tibble: 64,818 × 9\n##      gid  year agri_ih capdist  gwno nlights_mean pop_gpw_sum prec_gpcp  temp\n##    <dbl> <dbl>   <dbl>   <dbl> <dbl>        <dbl>       <dbl>     <dbl> <dbl>\n##  1 49182  2010      NA   2480.   155            0        9.68     1092. NA   \n##  2 49183  2010      NA   2483.   155            0       13.8      1092.  4.16\n##  3 49184  2010      NA   2485.   155            0       43.6      1092.  4.50\n##  4 49185  2010      NA   2488.   155            0        2.27     1092.  4.69\n##  5 49186  2010       0   2492.   155            0        0        1324.  4.78\n##  6 49898  2010      NA   2423.   155            0        1.71     1266.  3.84\n##  7 49899  2010      NA   2422.   155            0       48.2      1266.  3.73\n##  8 49900  2010      NA   2423.   155            0       43.7      1266.  3.61\n##  9 49901  2010       0   2423.   155            0      132.       1092.  3.58\n## 10 49902  2010       0   2425.   155            0      189.       1092.  3.70\n## # ℹ 64,808 more rows\n```\n:::\n\n\n\nAs you can see, I pulled nightlight data, population, precipitation, average temperatures, and the Gleditsch and Ward country identifiers (`gwno`).\n\n\nWe merge on `gid`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid_merged = left_join(grid, yearly_prio, by = \"gid\")\ngrid_merged |> head()\n## Simple feature collection with 6 features and 13 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: 163.5 ymin: 89.5 xmax: 166.5 ymax: 90\n## Geodetic CRS:  WGS 84\n## # A tibble: 6 × 14\n##      gid xcoord ycoord   col   row                                               geometry  year agri_ih capdist  gwno nlights_mean pop_gpw_sum prec_gpcp  temp\n##    <dbl>  <dbl>  <dbl> <dbl> <dbl>                                          <POLYGON [°]> <dbl>   <dbl>   <dbl> <dbl>        <dbl>       <dbl>     <dbl> <dbl>\n## 1 259168   164.   89.8   688   360 ((163.5 89.5, 163.5 90, 164 90, 164 89.5, 163.5 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n## 2 259169   164.   89.8   689   360   ((164 89.5, 164 90, 164.5 90, 164.5 89.5, 164 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n## 3 259170   165.   89.8   690   360 ((164.5 89.5, 164.5 90, 165 90, 165 89.5, 164.5 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n## 4 259171   165.   89.8   691   360   ((165 89.5, 165 90, 165.5 90, 165.5 89.5, 165 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n## 5 259172   166.   89.8   692   360 ((165.5 89.5, 165.5 90, 166 90, 166 89.5, 165.5 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n## 6 259173   166.   89.8   693   360   ((166 89.5, 166 90, 166.5 90, 166.5 89.5, 166 89.5))    NA      NA      NA    NA           NA          NA        NA    NA\n```\n:::\n\n\n\n\n## Cleaning the grid\n\n\nWe can take a couple more steps to make this data user-friendly. First, the Earth is mostly water so a lot of these cells are just water. We can get rid of the water by using the fact that the oceans (and other unclaimed territory) have missing `gwno` codes. Second, we can back out country names from `gwno` using `{countrycodes}`. Third, we can drop the coordinate variables:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclean_grid = grid_merged |> \n  drop_na(gwno) |> \n  mutate(country = countrycode::countrycode(gwno, origin = \"gwn\", destination = \"country.name\")) |> \n  select(gid, year, country, geometry, capdist, nlights_mean, pop_gpw_sum, prec_gpcp, temp)\n\nhead(clean_grid)\n## Simple feature collection with 6 features and 8 fields\n## Geometry type: POLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -76.5 ymin: 83 xmax: -73 ymax: 83.5\n## Geodetic CRS:  WGS 84\n## # A tibble: 6 × 9\n##      gid  year country                                             geometry capdist nlights_mean pop_gpw_sum prec_gpcp  temp\n##    <dbl> <dbl> <chr>                                          <POLYGON [°]>   <dbl>        <dbl>       <dbl>     <dbl> <dbl>\n## 1 249328  2010 Canada  ((-76.5 83, -76.5 83.5, -76 83.5, -76 83, -76.5 83))   4216.           NA    0.00886       170. -20.3\n## 2 249329  2010 Canada    ((-76 83, -76 83.5, -75.5 83.5, -75.5 83, -76 83))   4216.           NA    0.00612       170. -20.2\n## 3 249330  2010 Canada  ((-75.5 83, -75.5 83.5, -75 83.5, -75 83, -75.5 83))   4216.           NA    0.000397      170. -20.2\n## 4 249331  2010 Canada    ((-75 83, -75 83.5, -74.5 83.5, -74.5 83, -75 83))   4216.           NA    0.00357       172.  NA  \n## 5 249332  2010 Canada  ((-74.5 83, -74.5 83.5, -74 83.5, -74 83, -74.5 83))   4217.           NA    0.0119        172.  NA  \n## 6 249334  2010 Canada  ((-73.5 83, -73.5 83.5, -73 83.5, -73 83, -73.5 83))   4217.           NA    0.000209      172. -20.2\n```\n:::\n\n\n Notice that we are down to about 65,000 cells here. The oceans and Antartica are gone (and probably other stuff). \n\n\n## Plotting\n\n\nThe `{sf}` package works nicely with `ggplot`. We can plot the whole world:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(clean_grid) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nA specific country, Ethiopia, with cells filled by population:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclean_grid |> \n  filter(country == \"Ethiopia\") |> \n  ggplot(aes(fill = pop_gpw_sum)) + \n  geom_sf() + \n  scale_fill_viridis_c(option = \"inferno\", \n                       end = .9, \n                       trans = \"log10\", \n                       labels = scales::comma, \n                       name = \"\") + \n  labs(title = \"GRID-level population in Ethiopia\")\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nLog-transforming population is sometimes useful in maps, otherwise \"outlier\" units will swamp everything else, as with Addis Ababa below:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclean_grid |> \n  filter(country == \"Ethiopia\") |> \n  ggplot(aes(fill = pop_gpw_sum)) + \n  geom_sf() + \n  scale_fill_viridis_c(option = \"inferno\", \n                       end = .9, \n                       labels = scales::comma, \n                       name = \"\") + \n  labs(title = \"GRID-level population in Ethiopia\")\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\n\n## Finding neighbors\n\nDoing most forms of spatial analysis requires knowing how the different units in the data relate to one another. With spatial data, it's common to look at whether two units are *neighbors* or not. Being a neighbor might be defined as sharing a common border, the distances between the capitals, or centroids, or... whatever. \n\n\nLet's do this for just the United States, Mexico, and Canada:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nthree_countries = \n  clean_grid |> \n  filter(country %in% c(\"United States\", \"Mexico\", \"Canada\"))\n\nggplot(three_countries, aes(fill = country)) + geom_sf()\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\n\nTo describe these relationships, we use an *N* by *N* **adjacency matrix**, where *N* is the number of units in our data and any entry *(i,j)* tells us whether units *i* and *j* are neighbors or not. \n\nTo do this in R, I find the easiest thing is (unfortunately) to switch from `sf` to `spdep` package and use the `spdep::poly2nb()` function. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# convert back to sp object to use nice sp dep functions\nthree_countries_sp = as(three_countries, Class = \"Spatial\")\n```\n:::\n\n\n\n\nBelow, we specify `queen == FALSE` because we want to use Rook's contiguity (as opposed to Queen's). \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# get neighbors\nnb = spdep::poly2nb(three_countries_sp, \n             queen = FALSE, \n             row.names = three_countries_sp$gid)\n```\n:::\n\n\n\nThe output of our `nb` object looks like this, and tells us a bunch of information about what neighborhood relations among our units looks like, including whether any units were found to have no neighbors:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnb\n## Neighbour list object:\n## Number of regions: 13719 \n## Number of nonzero links: 52574 \n## Percentage nonzero weights: 0.02793 \n## Average number of links: 3.832 \n## 2 regions with no links:\n## 211700 209569\n## 19 disjoint connected subgraphs\n```\n:::\n\n\n\nSo, for example, `gid = 211700` has no neighbors. \n\n\nSomething prudent at this point would be to check whether the neighborhood list we got actually makes sense. \n\nFirst, let's look at a place that the `nb` object tells us has no neighbors, such as `gid = 211700`:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# plot place with no neighbors, Alaskan island\nthree_countries %>% \n  filter(country == \"Canada\") %>% \n  ggplot() + \n  geom_sf() + \n  # add the place with no neighbors (gid == 211700)\n  geom_sf(data = filter(three_countries, gid == 211700), fill = \"red\") + \n  # zoom in on location\n  coord_sf(xlim = c(-180, -140), ylim = c(50, 70), expand = FALSE)\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nChecks out: looks like some tiny island that *shouldn't* have neighbors. \n\n\n\nNow, how about a place that should have neighbors? Let's look at a random cell in Canada: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# plot place and its neighbors (in canada) # CHECKS OUT!\nthree_countries %>% \n  filter(country == \"Canada\") %>% \n  ggplot() + geom_sf() + \n  # random place in canada\n  geom_sf(data = filter(three_countries, gid == 249328), fill = \"red\") + \n  # neighbors from nb object\n  geom_sf(data = filter(three_countries, gid %in% c(249329,249327, 248608)), fill = \"blue\") + \n  # zoom in on location\n  coord_sf(xlim = c(-100, -50), ylim = c(75, 85), expand = FALSE)\n```\n\n::: {.cell-output-display}\n![](using-priogrid_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nA bit hard to make out, but if you zoom in you will see that the `nb` object correctly identified this GRID's neighbors. \n\n\n\n\n",
    "supporting": [
      "using-priogrid_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}